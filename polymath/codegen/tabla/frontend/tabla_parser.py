# Generated from /Users/seankinzer/ACTLab/rtml/project.rtml/tabla/compiler/frontend/Tabla.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3 ")
        buf.write("\u00ca\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\3\2\3\2")
        buf.write("\3\2\3\2\3\3\7\3@\n\3\f\3\16\3C\13\3\3\4\3\4\3\4\3\5\3")
        buf.write("\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5S\n\5\3\6\3")
        buf.write("\6\3\7\3\7\3\b\3\b\3\b\3\b\3\b\3\t\3\t\3\t\5\ta\n\t\3")
        buf.write("\n\3\n\3\n\3\13\3\13\3\f\3\f\3\f\3\r\3\r\3\r\3\r\3\r\5")
        buf.write("\rp\n\r\3\16\3\16\3\16\5\16u\n\16\3\17\3\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\3\20\7\20\177\n\20\f\20\16\20\u0082\13")
        buf.write("\20\3\20\5\20\u0085\n\20\3\21\3\21\3\21\3\21\3\21\3\22")
        buf.write("\3\22\3\22\3\23\3\23\3\24\3\24\3\24\3\24\3\24\3\24\3\24")
        buf.write("\3\24\3\24\3\24\3\24\5\24\u009c\n\24\3\25\3\25\3\25\3")
        buf.write("\25\3\25\5\25\u00a3\n\25\3\26\3\26\3\26\3\27\3\27\3\27")
        buf.write("\3\27\3\27\5\27\u00ad\n\27\3\30\3\30\3\30\3\31\3\31\3")
        buf.write("\31\3\31\3\31\5\31\u00b7\n\31\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\5\32\u00c2\n\32\3\33\3\33\3\34\3")
        buf.write("\34\3\35\3\35\3\35\2\2\36\2\4\6\b\n\f\16\20\22\24\26\30")
        buf.write("\32\34\36 \"$&(*,.\60\62\64\668\2\7\3\2\4\6\4\2\35\35")
        buf.write("  \3\2\16\24\3\2\t\n\3\2\13\f\2\u00bd\2:\3\2\2\2\4A\3")
        buf.write("\2\2\2\6D\3\2\2\2\bR\3\2\2\2\nT\3\2\2\2\fV\3\2\2\2\16")
        buf.write("X\3\2\2\2\20`\3\2\2\2\22b\3\2\2\2\24e\3\2\2\2\26g\3\2")
        buf.write("\2\2\30o\3\2\2\2\32t\3\2\2\2\34v\3\2\2\2\36\u0084\3\2")
        buf.write("\2\2 \u0086\3\2\2\2\"\u008b\3\2\2\2$\u008e\3\2\2\2&\u009b")
        buf.write("\3\2\2\2(\u00a2\3\2\2\2*\u00a4\3\2\2\2,\u00ac\3\2\2\2")
        buf.write(".\u00ae\3\2\2\2\60\u00b6\3\2\2\2\62\u00c1\3\2\2\2\64\u00c3")
        buf.write("\3\2\2\2\66\u00c5\3\2\2\28\u00c7\3\2\2\2:;\5\4\3\2;<\5")
        buf.write("\36\20\2<=\7\2\2\3=\3\3\2\2\2>@\5\6\4\2?>\3\2\2\2@C\3")
        buf.write("\2\2\2A?\3\2\2\2AB\3\2\2\2B\5\3\2\2\2CA\3\2\2\2DE\5\b")
        buf.write("\5\2EF\7\25\2\2F\7\3\2\2\2GH\5\n\6\2HI\5\22\n\2IS\3\2")
        buf.write("\2\2JK\7\7\2\2KS\5\16\b\2LM\5\f\7\2MN\5\34\17\2NS\3\2")
        buf.write("\2\2OP\7\35\2\2PQ\7\34\2\2QS\7 \2\2RG\3\2\2\2RJ\3\2\2")
        buf.write("\2RL\3\2\2\2RO\3\2\2\2S\t\3\2\2\2TU\t\2\2\2U\13\3\2\2")
        buf.write("\2VW\7\b\2\2W\r\3\2\2\2XY\5\24\13\2YZ\7\3\2\2Z[\5\24\13")
        buf.write("\2[\\\5\20\t\2\\\17\3\2\2\2]^\7\33\2\2^a\5\16\b\2_a\3")
        buf.write("\2\2\2`]\3\2\2\2`_\3\2\2\2a\21\3\2\2\2bc\5\24\13\2cd\5")
        buf.write("\32\16\2d\23\3\2\2\2ef\5\26\f\2f\25\3\2\2\2gh\7\35\2\2")
        buf.write("hi\5\30\r\2i\27\3\2\2\2jk\7\27\2\2kl\t\3\2\2lm\7\30\2")
        buf.write("\2mp\5\30\r\2np\3\2\2\2oj\3\2\2\2on\3\2\2\2p\31\3\2\2")
        buf.write("\2qr\7\33\2\2ru\5\22\n\2su\3\2\2\2tq\3\2\2\2ts\3\2\2\2")
        buf.write("u\33\3\2\2\2vw\7\35\2\2wx\7\27\2\2xy\t\3\2\2yz\7\26\2")
        buf.write("\2z{\t\3\2\2{|\7\30\2\2|\35\3\2\2\2}\177\5 \21\2~}\3\2")
        buf.write("\2\2\177\u0082\3\2\2\2\u0080~\3\2\2\2\u0080\u0081\3\2")
        buf.write("\2\2\u0081\u0085\3\2\2\2\u0082\u0080\3\2\2\2\u0083\u0085")
        buf.write("\3\2\2\2\u0084\u0080\3\2\2\2\u0084\u0083\3\2\2\2\u0085")
        buf.write("\37\3\2\2\2\u0086\u0087\5\24\13\2\u0087\u0088\7\34\2\2")
        buf.write("\u0088\u0089\5\"\22\2\u0089\u008a\7\25\2\2\u008a!\3\2")
        buf.write("\2\2\u008b\u008c\5*\26\2\u008c\u008d\5(\25\2\u008d#\3")
        buf.write("\2\2\2\u008e\u008f\t\4\2\2\u008f%\3\2\2\2\u0090\u0091")
        buf.write("\7\27\2\2\u0091\u0092\7\35\2\2\u0092\u0093\7\30\2\2\u0093")
        buf.write("\u0094\7\31\2\2\u0094\u0095\5\"\22\2\u0095\u0096\7\32")
        buf.write("\2\2\u0096\u009c\3\2\2\2\u0097\u0098\7\31\2\2\u0098\u0099")
        buf.write("\5\"\22\2\u0099\u009a\7\32\2\2\u009a\u009c\3\2\2\2\u009b")
        buf.write("\u0090\3\2\2\2\u009b\u0097\3\2\2\2\u009c\'\3\2\2\2\u009d")
        buf.write("\u009e\58\35\2\u009e\u009f\5*\26\2\u009f\u00a0\5(\25\2")
        buf.write("\u00a0\u00a3\3\2\2\2\u00a1\u00a3\3\2\2\2\u00a2\u009d\3")
        buf.write("\2\2\2\u00a2\u00a1\3\2\2\2\u00a3)\3\2\2\2\u00a4\u00a5")
        buf.write("\5.\30\2\u00a5\u00a6\5,\27\2\u00a6+\3\2\2\2\u00a7\u00a8")
        buf.write("\5\66\34\2\u00a8\u00a9\5.\30\2\u00a9\u00aa\5,\27\2\u00aa")
        buf.write("\u00ad\3\2\2\2\u00ab\u00ad\3\2\2\2\u00ac\u00a7\3\2\2\2")
        buf.write("\u00ac\u00ab\3\2\2\2\u00ad-\3\2\2\2\u00ae\u00af\5\62\32")
        buf.write("\2\u00af\u00b0\5\60\31\2\u00b0/\3\2\2\2\u00b1\u00b2\5")
        buf.write("\64\33\2\u00b2\u00b3\5\62\32\2\u00b3\u00b4\5\60\31\2\u00b4")
        buf.write("\u00b7\3\2\2\2\u00b5\u00b7\3\2\2\2\u00b6\u00b1\3\2\2\2")
        buf.write("\u00b6\u00b5\3\2\2\2\u00b7\61\3\2\2\2\u00b8\u00c2\5\24")
        buf.write("\13\2\u00b9\u00ba\7\31\2\2\u00ba\u00bb\5\"\22\2\u00bb")
        buf.write("\u00bc\7\32\2\2\u00bc\u00c2\3\2\2\2\u00bd\u00c2\7 \2\2")
        buf.write("\u00be\u00bf\5$\23\2\u00bf\u00c0\5&\24\2\u00c0\u00c2\3")
        buf.write("\2\2\2\u00c1\u00b8\3\2\2\2\u00c1\u00b9\3\2\2\2\u00c1\u00bd")
        buf.write("\3\2\2\2\u00c1\u00be\3\2\2\2\u00c2\63\3\2\2\2\u00c3\u00c4")
        buf.write("\7\r\2\2\u00c4\65\3\2\2\2\u00c5\u00c6\t\5\2\2\u00c6\67")
        buf.write("\3\2\2\2\u00c7\u00c8\t\6\2\2\u00c89\3\2\2\2\16AR`ot\u0080")
        buf.write("\u0084\u009b\u00a2\u00ac\u00b6\u00c1")
        return buf.getvalue()


class TablaParser ( Parser ):

    grammarFileName = "Tabla.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'->'", "'model_input'", "'model_output'", 
                     "'model'", "'gradient'", "'iterator'", "'+'", "'-'", 
                     "'<'", "'>'", "'*'", "'pi'", "'sum'", "'norm'", "'gaussian'", 
                     "'sigmoid'", "'sigmoid_symmetric'", "'log'", "';'", 
                     "':'", "'['", "']'", "'('", "')'", "','", "'='" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "MODEL_INPUT", "MODEL_OUTPUT", 
                      "MODEL", "GRADIENT", "ITERATOR", "ADD", "SUB", "LT", 
                      "GT", "MUL", "PI", "SUM", "NORM", "GAUSSIAN", "SIGMOID", 
                      "SIG_SYM", "LOG", "SEMI", "COLON", "LEFT_BRACK", "RIGHT_BRACK", 
                      "LEFT_PAREN", "RIGHT_PAREN", "COMMA", "ASSIGN", "ID", 
                      "WHITESPACE", "COMMENT", "INTLIT" ]

    RULE_program = 0
    RULE_data_decl_list = 1
    RULE_data_decl = 2
    RULE_data_type = 3
    RULE_non_iterator = 4
    RULE_iterator = 5
    RULE_var_with_link_list = 6
    RULE_var_with_link_list_tail = 7
    RULE_var_list = 8
    RULE_var = 9
    RULE_var_id = 10
    RULE_id_tail = 11
    RULE_var_list_tail = 12
    RULE_var_list_iterator = 13
    RULE_stat_list = 14
    RULE_stat = 15
    RULE_expr = 16
    RULE_function = 17
    RULE_function_args = 18
    RULE_term2_tail = 19
    RULE_term2 = 20
    RULE_term1_tail = 21
    RULE_term1 = 22
    RULE_term0_tail = 23
    RULE_term0 = 24
    RULE_mul_op = 25
    RULE_add_op = 26
    RULE_compare_op = 27

    ruleNames =  [ "program", "data_decl_list", "data_decl", "data_type", 
                   "non_iterator", "iterator", "var_with_link_list", "var_with_link_list_tail", 
                   "var_list", "var", "var_id", "id_tail", "var_list_tail", 
                   "var_list_iterator", "stat_list", "stat", "expr", "function", 
                   "function_args", "term2_tail", "term2", "term1_tail", 
                   "term1", "term0_tail", "term0", "mul_op", "add_op", "compare_op" ]

    EOF = Token.EOF
    T__0=1
    MODEL_INPUT=2
    MODEL_OUTPUT=3
    MODEL=4
    GRADIENT=5
    ITERATOR=6
    ADD=7
    SUB=8
    LT=9
    GT=10
    MUL=11
    PI=12
    SUM=13
    NORM=14
    GAUSSIAN=15
    SIGMOID=16
    SIG_SYM=17
    LOG=18
    SEMI=19
    COLON=20
    LEFT_BRACK=21
    RIGHT_BRACK=22
    LEFT_PAREN=23
    RIGHT_PAREN=24
    COMMA=25
    ASSIGN=26
    ID=27
    WHITESPACE=28
    COMMENT=29
    INTLIT=30

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_decl_list(self):
            return self.getTypedRuleContext(TablaParser.Data_decl_listContext,0)


        def stat_list(self):
            return self.getTypedRuleContext(TablaParser.Stat_listContext,0)


        def EOF(self):
            return self.getToken(TablaParser.EOF, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_program

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProgram" ):
                listener.enterProgram(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProgram" ):
                listener.exitProgram(self)




    def program(self):

        localctx = TablaParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 56
            self.data_decl_list()
            self.state = 57
            self.stat_list()
            self.state = 58
            self.match(TablaParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_decl_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_decl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TablaParser.Data_declContext)
            else:
                return self.getTypedRuleContext(TablaParser.Data_declContext,i)


        def getRuleIndex(self):
            return TablaParser.RULE_data_decl_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_decl_list" ):
                listener.enterData_decl_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_decl_list" ):
                listener.exitData_decl_list(self)




    def data_decl_list(self):

        localctx = TablaParser.Data_decl_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_data_decl_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 60
                    self.data_decl() 
                self.state = 65
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_declContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_type(self):
            return self.getTypedRuleContext(TablaParser.Data_typeContext,0)


        def SEMI(self):
            return self.getToken(TablaParser.SEMI, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_data_decl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_decl" ):
                listener.enterData_decl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_decl" ):
                listener.exitData_decl(self)




    def data_decl(self):

        localctx = TablaParser.Data_declContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_data_decl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 66
            self.data_type()
            self.state = 67
            self.match(TablaParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def non_iterator(self):
            return self.getTypedRuleContext(TablaParser.Non_iteratorContext,0)


        def var_list(self):
            return self.getTypedRuleContext(TablaParser.Var_listContext,0)


        def GRADIENT(self):
            return self.getToken(TablaParser.GRADIENT, 0)

        def var_with_link_list(self):
            return self.getTypedRuleContext(TablaParser.Var_with_link_listContext,0)


        def iterator(self):
            return self.getTypedRuleContext(TablaParser.IteratorContext,0)


        def var_list_iterator(self):
            return self.getTypedRuleContext(TablaParser.Var_list_iteratorContext,0)


        def ID(self):
            return self.getToken(TablaParser.ID, 0)

        def ASSIGN(self):
            return self.getToken(TablaParser.ASSIGN, 0)

        def INTLIT(self):
            return self.getToken(TablaParser.INTLIT, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_data_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_type" ):
                listener.enterData_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_type" ):
                listener.exitData_type(self)




    def data_type(self):

        localctx = TablaParser.Data_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_data_type)
        try:
            self.state = 80
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TablaParser.MODEL_INPUT, TablaParser.MODEL_OUTPUT, TablaParser.MODEL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 69
                self.non_iterator()
                self.state = 70
                self.var_list()
                pass
            elif token in [TablaParser.GRADIENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 72
                self.match(TablaParser.GRADIENT)
                self.state = 73
                self.var_with_link_list()
                pass
            elif token in [TablaParser.ITERATOR]:
                self.enterOuterAlt(localctx, 3)
                self.state = 74
                self.iterator()
                self.state = 75
                self.var_list_iterator()
                pass
            elif token in [TablaParser.ID]:
                self.enterOuterAlt(localctx, 4)
                self.state = 77
                self.match(TablaParser.ID)
                self.state = 78
                self.match(TablaParser.ASSIGN)
                self.state = 79
                self.match(TablaParser.INTLIT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Non_iteratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MODEL_INPUT(self):
            return self.getToken(TablaParser.MODEL_INPUT, 0)

        def MODEL_OUTPUT(self):
            return self.getToken(TablaParser.MODEL_OUTPUT, 0)

        def MODEL(self):
            return self.getToken(TablaParser.MODEL, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_non_iterator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_iterator" ):
                listener.enterNon_iterator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_iterator" ):
                listener.exitNon_iterator(self)




    def non_iterator(self):

        localctx = TablaParser.Non_iteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_non_iterator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 82
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TablaParser.MODEL_INPUT) | (1 << TablaParser.MODEL_OUTPUT) | (1 << TablaParser.MODEL))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IteratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ITERATOR(self):
            return self.getToken(TablaParser.ITERATOR, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_iterator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIterator" ):
                listener.enterIterator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIterator" ):
                listener.exitIterator(self)




    def iterator(self):

        localctx = TablaParser.IteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_iterator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 84
            self.match(TablaParser.ITERATOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_with_link_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TablaParser.VarContext)
            else:
                return self.getTypedRuleContext(TablaParser.VarContext,i)


        def var_with_link_list_tail(self):
            return self.getTypedRuleContext(TablaParser.Var_with_link_list_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var_with_link_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_with_link_list" ):
                listener.enterVar_with_link_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_with_link_list" ):
                listener.exitVar_with_link_list(self)




    def var_with_link_list(self):

        localctx = TablaParser.Var_with_link_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_var_with_link_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 86
            self.var()
            self.state = 87
            self.match(TablaParser.T__0)
            self.state = 88
            self.var()
            self.state = 89
            self.var_with_link_list_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_with_link_list_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(TablaParser.COMMA, 0)

        def var_with_link_list(self):
            return self.getTypedRuleContext(TablaParser.Var_with_link_listContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var_with_link_list_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_with_link_list_tail" ):
                listener.enterVar_with_link_list_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_with_link_list_tail" ):
                listener.exitVar_with_link_list_tail(self)




    def var_with_link_list_tail(self):

        localctx = TablaParser.Var_with_link_list_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_var_with_link_list_tail)
        try:
            self.state = 94
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TablaParser.COMMA]:
                self.enterOuterAlt(localctx, 1)
                self.state = 91
                self.match(TablaParser.COMMA)
                self.state = 92
                self.var_with_link_list()
                pass
            elif token in [TablaParser.SEMI]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(TablaParser.VarContext,0)


        def var_list_tail(self):
            return self.getTypedRuleContext(TablaParser.Var_list_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list" ):
                listener.enterVar_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list" ):
                listener.exitVar_list(self)




    def var_list(self):

        localctx = TablaParser.Var_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_var_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.var()
            self.state = 97
            self.var_list_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var_id(self):
            return self.getTypedRuleContext(TablaParser.Var_idContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)




    def var(self):

        localctx = TablaParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 99
            self.var_id()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_idContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(TablaParser.ID, 0)

        def id_tail(self):
            return self.getTypedRuleContext(TablaParser.Id_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var_id

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_id" ):
                listener.enterVar_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_id" ):
                listener.exitVar_id(self)




    def var_id(self):

        localctx = TablaParser.Var_idContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_var_id)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 101
            self.match(TablaParser.ID)
            self.state = 102
            self.id_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Id_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACK(self):
            return self.getToken(TablaParser.LEFT_BRACK, 0)

        def RIGHT_BRACK(self):
            return self.getToken(TablaParser.RIGHT_BRACK, 0)

        def id_tail(self):
            return self.getTypedRuleContext(TablaParser.Id_tailContext,0)


        def ID(self):
            return self.getToken(TablaParser.ID, 0)

        def INTLIT(self):
            return self.getToken(TablaParser.INTLIT, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_id_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterId_tail" ):
                listener.enterId_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitId_tail" ):
                listener.exitId_tail(self)




    def id_tail(self):

        localctx = TablaParser.Id_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_id_tail)
        self._la = 0 # Token type
        try:
            self.state = 109
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TablaParser.LEFT_BRACK]:
                self.enterOuterAlt(localctx, 1)
                self.state = 104
                self.match(TablaParser.LEFT_BRACK)
                self.state = 105
                _la = self._input.LA(1)
                if not(_la==TablaParser.ID or _la==TablaParser.INTLIT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 106
                self.match(TablaParser.RIGHT_BRACK)
                self.state = 107
                self.id_tail()
                pass
            elif token in [TablaParser.T__0, TablaParser.ADD, TablaParser.SUB, TablaParser.LT, TablaParser.GT, TablaParser.MUL, TablaParser.SEMI, TablaParser.RIGHT_PAREN, TablaParser.COMMA, TablaParser.ASSIGN]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_list_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(TablaParser.COMMA, 0)

        def var_list(self):
            return self.getTypedRuleContext(TablaParser.Var_listContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_var_list_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list_tail" ):
                listener.enterVar_list_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list_tail" ):
                listener.exitVar_list_tail(self)




    def var_list_tail(self):

        localctx = TablaParser.Var_list_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_var_list_tail)
        try:
            self.state = 114
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TablaParser.COMMA]:
                self.enterOuterAlt(localctx, 1)
                self.state = 111
                self.match(TablaParser.COMMA)
                self.state = 112
                self.var_list()
                pass
            elif token in [TablaParser.SEMI]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Var_list_iteratorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(TablaParser.ID)
            else:
                return self.getToken(TablaParser.ID, i)

        def LEFT_BRACK(self):
            return self.getToken(TablaParser.LEFT_BRACK, 0)

        def COLON(self):
            return self.getToken(TablaParser.COLON, 0)

        def RIGHT_BRACK(self):
            return self.getToken(TablaParser.RIGHT_BRACK, 0)

        def INTLIT(self, i:int=None):
            if i is None:
                return self.getTokens(TablaParser.INTLIT)
            else:
                return self.getToken(TablaParser.INTLIT, i)

        def getRuleIndex(self):
            return TablaParser.RULE_var_list_iterator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar_list_iterator" ):
                listener.enterVar_list_iterator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar_list_iterator" ):
                listener.exitVar_list_iterator(self)




    def var_list_iterator(self):

        localctx = TablaParser.Var_list_iteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_var_list_iterator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self.match(TablaParser.ID)
            self.state = 117
            self.match(TablaParser.LEFT_BRACK)
            self.state = 118
            _la = self._input.LA(1)
            if not(_la==TablaParser.ID or _la==TablaParser.INTLIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 119
            self.match(TablaParser.COLON)
            self.state = 120
            _la = self._input.LA(1)
            if not(_la==TablaParser.ID or _la==TablaParser.INTLIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 121
            self.match(TablaParser.RIGHT_BRACK)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Stat_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stat(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(TablaParser.StatContext)
            else:
                return self.getTypedRuleContext(TablaParser.StatContext,i)


        def getRuleIndex(self):
            return TablaParser.RULE_stat_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat_list" ):
                listener.enterStat_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat_list" ):
                listener.exitStat_list(self)




    def stat_list(self):

        localctx = TablaParser.Stat_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_stat_list)
        self._la = 0 # Token type
        try:
            self.state = 130
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 126
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==TablaParser.ID:
                    self.state = 123
                    self.stat()
                    self.state = 128
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(TablaParser.VarContext,0)


        def ASSIGN(self):
            return self.getToken(TablaParser.ASSIGN, 0)

        def expr(self):
            return self.getTypedRuleContext(TablaParser.ExprContext,0)


        def SEMI(self):
            return self.getToken(TablaParser.SEMI, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_stat

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStat" ):
                listener.enterStat(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStat" ):
                listener.exitStat(self)




    def stat(self):

        localctx = TablaParser.StatContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_stat)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 132
            self.var()
            self.state = 133
            self.match(TablaParser.ASSIGN)
            self.state = 134
            self.expr()
            self.state = 135
            self.match(TablaParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term2(self):
            return self.getTypedRuleContext(TablaParser.Term2Context,0)


        def term2_tail(self):
            return self.getTypedRuleContext(TablaParser.Term2_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)




    def expr(self):

        localctx = TablaParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_expr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 137
            self.term2()
            self.state = 138
            self.term2_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PI(self):
            return self.getToken(TablaParser.PI, 0)

        def SUM(self):
            return self.getToken(TablaParser.SUM, 0)

        def NORM(self):
            return self.getToken(TablaParser.NORM, 0)

        def GAUSSIAN(self):
            return self.getToken(TablaParser.GAUSSIAN, 0)

        def SIGMOID(self):
            return self.getToken(TablaParser.SIGMOID, 0)

        def SIG_SYM(self):
            return self.getToken(TablaParser.SIG_SYM, 0)

        def LOG(self):
            return self.getToken(TablaParser.LOG, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction" ):
                listener.enterFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction" ):
                listener.exitFunction(self)




    def function(self):

        localctx = TablaParser.FunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 140
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TablaParser.PI) | (1 << TablaParser.SUM) | (1 << TablaParser.NORM) | (1 << TablaParser.GAUSSIAN) | (1 << TablaParser.SIGMOID) | (1 << TablaParser.SIG_SYM) | (1 << TablaParser.LOG))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_argsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACK(self):
            return self.getToken(TablaParser.LEFT_BRACK, 0)

        def ID(self):
            return self.getToken(TablaParser.ID, 0)

        def RIGHT_BRACK(self):
            return self.getToken(TablaParser.RIGHT_BRACK, 0)

        def LEFT_PAREN(self):
            return self.getToken(TablaParser.LEFT_PAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(TablaParser.ExprContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(TablaParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_function_args

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_args" ):
                listener.enterFunction_args(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_args" ):
                listener.exitFunction_args(self)




    def function_args(self):

        localctx = TablaParser.Function_argsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_function_args)
        try:
            self.state = 153
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TablaParser.LEFT_BRACK]:
                self.enterOuterAlt(localctx, 1)
                self.state = 142
                self.match(TablaParser.LEFT_BRACK)
                self.state = 143
                self.match(TablaParser.ID)
                self.state = 144
                self.match(TablaParser.RIGHT_BRACK)
                self.state = 145
                self.match(TablaParser.LEFT_PAREN)
                self.state = 146
                self.expr()
                self.state = 147
                self.match(TablaParser.RIGHT_PAREN)
                pass
            elif token in [TablaParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 149
                self.match(TablaParser.LEFT_PAREN)
                self.state = 150
                self.expr()
                self.state = 151
                self.match(TablaParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Term2_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def compare_op(self):
            return self.getTypedRuleContext(TablaParser.Compare_opContext,0)


        def term2(self):
            return self.getTypedRuleContext(TablaParser.Term2Context,0)


        def term2_tail(self):
            return self.getTypedRuleContext(TablaParser.Term2_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term2_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm2_tail" ):
                listener.enterTerm2_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm2_tail" ):
                listener.exitTerm2_tail(self)




    def term2_tail(self):

        localctx = TablaParser.Term2_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_term2_tail)
        try:
            self.state = 160
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TablaParser.LT, TablaParser.GT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 155
                self.compare_op()
                self.state = 156
                self.term2()
                self.state = 157
                self.term2_tail()
                pass
            elif token in [TablaParser.SEMI, TablaParser.RIGHT_PAREN]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Term2Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term1(self):
            return self.getTypedRuleContext(TablaParser.Term1Context,0)


        def term1_tail(self):
            return self.getTypedRuleContext(TablaParser.Term1_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term2

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm2" ):
                listener.enterTerm2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm2" ):
                listener.exitTerm2(self)




    def term2(self):

        localctx = TablaParser.Term2Context(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_term2)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.term1()
            self.state = 163
            self.term1_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Term1_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def add_op(self):
            return self.getTypedRuleContext(TablaParser.Add_opContext,0)


        def term1(self):
            return self.getTypedRuleContext(TablaParser.Term1Context,0)


        def term1_tail(self):
            return self.getTypedRuleContext(TablaParser.Term1_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term1_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm1_tail" ):
                listener.enterTerm1_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm1_tail" ):
                listener.exitTerm1_tail(self)




    def term1_tail(self):

        localctx = TablaParser.Term1_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_term1_tail)
        try:
            self.state = 170
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TablaParser.ADD, TablaParser.SUB]:
                self.enterOuterAlt(localctx, 1)
                self.state = 165
                self.add_op()
                self.state = 166
                self.term1()
                self.state = 167
                self.term1_tail()
                pass
            elif token in [TablaParser.LT, TablaParser.GT, TablaParser.SEMI, TablaParser.RIGHT_PAREN]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Term1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def term0(self):
            return self.getTypedRuleContext(TablaParser.Term0Context,0)


        def term0_tail(self):
            return self.getTypedRuleContext(TablaParser.Term0_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm1" ):
                listener.enterTerm1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm1" ):
                listener.exitTerm1(self)




    def term1(self):

        localctx = TablaParser.Term1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_term1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.term0()
            self.state = 173
            self.term0_tail()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Term0_tailContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def mul_op(self):
            return self.getTypedRuleContext(TablaParser.Mul_opContext,0)


        def term0(self):
            return self.getTypedRuleContext(TablaParser.Term0Context,0)


        def term0_tail(self):
            return self.getTypedRuleContext(TablaParser.Term0_tailContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term0_tail

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm0_tail" ):
                listener.enterTerm0_tail(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm0_tail" ):
                listener.exitTerm0_tail(self)




    def term0_tail(self):

        localctx = TablaParser.Term0_tailContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_term0_tail)
        try:
            self.state = 180
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TablaParser.MUL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 175
                self.mul_op()
                self.state = 176
                self.term0()
                self.state = 177
                self.term0_tail()
                pass
            elif token in [TablaParser.ADD, TablaParser.SUB, TablaParser.LT, TablaParser.GT, TablaParser.SEMI, TablaParser.RIGHT_PAREN]:
                self.enterOuterAlt(localctx, 2)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Term0Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(TablaParser.VarContext,0)


        def LEFT_PAREN(self):
            return self.getToken(TablaParser.LEFT_PAREN, 0)

        def expr(self):
            return self.getTypedRuleContext(TablaParser.ExprContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(TablaParser.RIGHT_PAREN, 0)

        def INTLIT(self):
            return self.getToken(TablaParser.INTLIT, 0)

        def function(self):
            return self.getTypedRuleContext(TablaParser.FunctionContext,0)


        def function_args(self):
            return self.getTypedRuleContext(TablaParser.Function_argsContext,0)


        def getRuleIndex(self):
            return TablaParser.RULE_term0

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm0" ):
                listener.enterTerm0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm0" ):
                listener.exitTerm0(self)




    def term0(self):

        localctx = TablaParser.Term0Context(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_term0)
        try:
            self.state = 191
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TablaParser.ID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 182
                self.var()
                pass
            elif token in [TablaParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 183
                self.match(TablaParser.LEFT_PAREN)
                self.state = 184
                self.expr()
                self.state = 185
                self.match(TablaParser.RIGHT_PAREN)
                pass
            elif token in [TablaParser.INTLIT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 187
                self.match(TablaParser.INTLIT)
                pass
            elif token in [TablaParser.PI, TablaParser.SUM, TablaParser.NORM, TablaParser.GAUSSIAN, TablaParser.SIGMOID, TablaParser.SIG_SYM, TablaParser.LOG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 188
                self.function()
                self.state = 189
                self.function_args()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mul_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MUL(self):
            return self.getToken(TablaParser.MUL, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_mul_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMul_op" ):
                listener.enterMul_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMul_op" ):
                listener.exitMul_op(self)




    def mul_op(self):

        localctx = TablaParser.Mul_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_mul_op)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(TablaParser.MUL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Add_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(TablaParser.ADD, 0)

        def SUB(self):
            return self.getToken(TablaParser.SUB, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_add_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd_op" ):
                listener.enterAdd_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd_op" ):
                listener.exitAdd_op(self)




    def add_op(self):

        localctx = TablaParser.Add_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_add_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 195
            _la = self._input.LA(1)
            if not(_la==TablaParser.ADD or _la==TablaParser.SUB):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Compare_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LT(self):
            return self.getToken(TablaParser.LT, 0)

        def GT(self):
            return self.getToken(TablaParser.GT, 0)

        def getRuleIndex(self):
            return TablaParser.RULE_compare_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompare_op" ):
                listener.enterCompare_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompare_op" ):
                listener.exitCompare_op(self)




    def compare_op(self):

        localctx = TablaParser.Compare_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_compare_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            _la = self._input.LA(1)
            if not(_la==TablaParser.LT or _la==TablaParser.GT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





