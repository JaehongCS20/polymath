syntax = "proto3";

package srdfg;


message Program {
    string name = 1;
    map<string, Template> templates = 2;
    Node graph = 3;
}

message Expression {
  string expr_str = 1;
  bool temp_assign = 2;
  repeated int64 inputs = 3;
  repeated int64 outputs = 4;
  repeated string domain_vars = 5;
  repeated string assumptions = 6;
  repeated string comp_domains = 7;

}

message Variable {
  string name = 1;
  string dtype = 2;
  string type_modifier = 3;
    message Dimension {
        oneof value {
            int64 dim_int = 1;
            string dim_id = 2;
        }
    };
  repeated Dimension dimensions = 4;
  DataValue value = 5;
  repeated int64 src_nodes = 6;
  repeated int64 sink_nodes = 7;
  string ref_var = 8;
  repeated string ref_var_domain = 9;

  message Index {
    oneof lower {
      int64 lbound_val = 1;
      string lbound_var = 2;
    };
    oneof upper {
      int64 ubound_val = 3;
      string ubound_var = 4;
    };
  }

  Index index = 10;
}

message Template {
  string name = 1;
  repeated Node nodes = 2;
  repeated Edge edges = 3;
  repeated string signature = 4;
  repeated Variable symbols = 5;
  repeated Expression expressions = 6;
}

message Domain {
    message DomainVal {
        oneof value {
            int64 dom_edge = 1;
            string dim_id = 2;
        }
    };
    repeated DomainVal domains = 1;
}

message Edge {

    int64 edge_id = 1;
    int64 source_id = 2;
    int64 dest_id = 3;
    string dtype = 4;
    string var_key = 5;
    string edge_name = 6;
    Domain domains = 7;
    repeated string indices = 8;

}

message Node {
    int64 node_id = 1;
    string op_name = 2;
    string node_expr = 3;
    string dtype = 4;
    repeated int64 in_edges = 5;
    repeated int64 out_edges = 6;
    repeated Node nodes = 7;
    repeated Edge edges = 8;
    repeated Variable symbols = 9;
    repeated Domain input_domains  = 10;
    Domain op_domains  = 11;
    Domain group_op_bounds = 12;
    repeated string edge_text = 13;
    repeated string template_args = 14;
    string var_name = 15;
}


message DataValue {

    enum DataType {
        UNDEFINED = 0;
        // Basic types.
        FLOAT = 1;   // float
        UINT8 = 2;   // uint8_t
        INT8 = 3;    // int8_t
        UINT16 = 4;  // uint16_t
        INT16 = 5;   // int16_t
        INT32 = 6;   // int32_t
        INT64 = 7;   // int64_t
        STRING = 8;  // string
        BOOL = 9;    // bool

        // IEEE754 half-precision floating-point format (16 bits wide).
        // This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
        FLOAT16 = 10;

        DOUBLE = 11;
        UINT32 = 12;
        UINT64 = 13;
        COMPLEX64 = 14;     // complex with float32 real and imaginary components
        COMPLEX128 = 15;    // complex with float64 real and imaginary components

        // Non-IEEE floating-point format based on IEEE754 single-precision
        // floating-point number truncated to 16 bits.
        // This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
        BFLOAT16 = 16;
        TENSOR = 17;
        TENSORS = 18;

        // Future extensions go here.
    }

    string name = 1;
    string ref_attr_name = 21;
    float f = 2;
    int32 i32 = 3;
    int64 i64 = 5;
    bytes s = 6;
    double d = 7;
    uint64 ui64 = 8;
    bool b = 9;
    Tensor t = 10;
    repeated Tensor tensors = 11;  // list of tensors
    DataType type = 12;   // discriminator that indicates which field below is in use

}

// A message defined to store a tensor in its serialized format.
message Tensor {
    enum DataType {
        UNDEFINED = 0;
        // Basic types.
        FLOAT = 1;   // float
        UINT8 = 2;   // uint8_t
        INT8 = 3;    // int8_t
        UINT16 = 4;  // uint16_t
        INT16 = 5;   // int16_t
        INT32 = 6;   // int32_t
        INT64 = 7;   // int64_t
        STRING = 8;  // string
        BOOL = 9;    // bool

        // IEEE754 half-precision floating-point format (16 bits wide).
        // This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
        FLOAT16 = 10;

        DOUBLE = 11;
        UINT32 = 12;
        UINT64 = 13;
        COMPLEX64 = 14;     // complex with float32 real and imaginary components
        COMPLEX128 = 15;    // complex with float64 real and imaginary components

        // Non-IEEE floating-point format based on IEEE754 single-precision
        // floating-point number truncated to 16 bits.
        // This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
        BFLOAT16 = 16;
    }

    repeated int64 dims = 1;

    int32 data_type = 2;
    message Segment {
        int64 begin = 1;
        int64 end = 2;
    }
    Segment segment = 3;

    repeated float float_data = 4 [packed = true];
    repeated int32 int32_data = 5 [packed = true];
    repeated bytes string_data = 6;
    repeated int64 int64_data = 7 [packed = true];
    repeated double double_data = 8 [packed = true];
    repeated uint64 uint64_data = 9 [packed = true];
    string data_format = 10; // namespace Value
    bytes raw_data = 11;
    map<string,string> external_data = 13;

    enum DataLocation {
        DEFAULT = 0;
        EXTERNAL = 1;
    }
    DataLocation data_location = 14;

}

// Defines a tensor shape. A dimension can be either an integer value
// or a symbolic variable. A symbolic variable represents an unknown
// dimension.
message TensorShape {
  message Dimension {
    oneof value {
      int64 dim_value = 1;
      string dim_param = 2;   // namespace Shape
    };
    string denotation = 3;

  };
  repeated Dimension dim = 1;
}
